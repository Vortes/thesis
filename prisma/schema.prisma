// This is your Prisma schema file

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id         String @id @default(cuid())
  email      String @unique
  first_name String
  last_name  String

  latitude  Float?
  longitude Float?

  // Relationships
  sentShipments     Shipment[] @relation("Sender")
  receivedShipments Shipment[] @relation("Recipient")

  // A user can be part of many connections
  connectionsAsInitiator Connection[] @relation("Initiator")
  connectionsAsReceiver  Connection[] @relation("Receiver")
  invitations            Invitation[]
  onboarding             Onboarding?
}

model Onboarding {
  id        String   @id @default(cuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id])
  completed Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Connection {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  initiatorId String
  initiator   User   @relation("Initiator", fields: [initiatorId], references: [id])

  recipientId String
  recipient   User   @relation("Receiver", fields: [recipientId], references: [id])

  status ConnectionStatus @default(PENDING)

  // The Virtual Messenger belongs to the RELATIONSHIP
  messenger Messenger?

  @@unique([initiatorId, recipientId]) // Prevent duplicate friendships
}

model Messenger {
  id           String     @id @default(cuid())
  name         String // e.g., "Hermes" or "Rizzo"
  connectionId String     @unique
  connection   Connection @relation(fields: [connectionId], references: [id])

  // Visual Customization (for your 3D/Frontend assets)
  skinId String @default("default_messenger")

  // Detailed status tracking
  status MessengerStatus @default(AVAILABLE)

  // Current shipment being carried (null when available)
  currentShipmentId String?   @unique
  currentShipment   Shipment? @relation("CarryingMessenger", fields: [currentShipmentId], references: [id])

  // Which user currently "has" the messenger (can send next)
  // This alternates between connection initiator/recipient
  currentHolderId String?

  // Track if each user has seen the Hau reveal experience
  revealedToInitiator Boolean @default(false)
  revealedToRecipient Boolean @default(false)

  // Reverse relation for shipments this messenger has carried
  shipments Shipment[] @relation("ShipmentMessenger")
}

model Shipment {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Who and Where
  senderId    String
  sender      User   @relation("Sender", fields: [senderId], references: [id])
  recipientId String
  recipient   User   @relation("Recipient", fields: [recipientId], references: [id])

  // The Payload
  items GiftItem[]

  // The Journey Logic
  status          ShipmentStatus @default(DRAFTING)
  dispatchedAt    DateTime? // When the user hit "Send"
  arrivalEstimate DateTime? // Calculated: dispatchedAt + travel_time

  // Metadata for the journey visualization
  distanceInKm Float?

  // Snapshot of coordinates at dispatch time (from User locations)
  originLat Float?
  originLng Float?
  destLat   Float?
  destLng   Float?

  // Link to messenger carrying this shipment
  messengerId String?
  messenger   Messenger? @relation("ShipmentMessenger", fields: [messengerId], references: [id])

  // For recall functionality
  recalledAt DateTime? // When sender cancelled (null if not recalled)

  // Reverse relation for currentShipment on Messenger
  carryingMessenger Messenger? @relation("CarryingMessenger")
}

model GiftItem {
  id         String   @id @default(cuid())
  shipmentId String
  shipment   Shipment @relation(fields: [shipmentId], references: [id], onDelete: Cascade)

  type GiftType // TEXT, AUDIO, DRAWING

  // For text, store here. For Audio/Drawing, store S3/R2 URL here.
  content String @db.Text
}

// Enums
enum ConnectionStatus {
  PENDING
  ACTIVE
  BLOCKED
  ACCEPTED
}

enum ShipmentStatus {
  DRAFTING // User is still adding items
  IN_TRANSIT // Messenger is traveling
  ARRIVED // Messenger arrived, waiting to be opened
  OPENED // User has viewed it
  RECALLED // Sender cancelled, messenger returning
}

enum MessengerStatus {
  AVAILABLE // Ready to accept new shipment
  LOADING // User is composing a shipment
  IN_TRANSIT // Traveling to recipient
  WAITING // Arrived, waiting for recipient to open/reply
  RETURNING // Heading back after recall
}

enum GiftType {
  TEXT
  AUDIO
  DRAWING
  LINK
  PHOTO
}

model Invitation {
  id        String           @id @default(cuid())
  email     String
  token     String           @unique // Random string, not a JWT
  senderId  String
  sender    User             @relation(fields: [senderId], references: [id])
  status    InvitationStatus @default(PENDING)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  @@unique([email, senderId])
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
}
